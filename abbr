OPT_SOURCE="$HOME"/.zsh_abbrs
ABBR_OPT_GLOBAL=false
ABBR_OPT_UNIVERSAL=true

MAN="
    abbr(zsh) is a Zsh port of fish shell's abbr


    The following are the fish shell abbr's docs as of v3.0.0, December 28 2018
    Source: https://fishshell.com/docs/current/commands.html


       abbr - manage fish abbreviations

   Synopsis
       abbr --add [SCOPE] WORD EXPANSION
       abbr --erase word
       abbr --rename [SCOPE] OLD_WORD NEW_WORD
       abbr --show
       abbr --list

   Description
       abbr manages abbreviations - user-defined words that are replaced with longer phrases after they are entered.

       For example, a frequently-run command like git checkout can be abbreviated to gco. After entering gco and pressing
       [Space] or [Enter], the full text git checkout will appear in the command line.

   Options
       The following options are available:

       o -a WORD EXPANSION or --add WORD EXPANSION Adds a new abbreviation, causing WORD to be expanded to PHRASE.

       o -r OLD_WORD NEW_WORD or --rename OLD_WORD NEW_WORD Renames an abbreviation, from OLD_WORD to NEW_WORD.

       o -s or --show Show all abbreviations in a manner suitable for export and import.

       o -l or --list Lists all abbreviated words.

       o -e WORD or --erase WORD Erase the abbreviation WORD.

       In addition, when adding abbreviations:

       o -g or --global to use a global variable.

       o -U or --universal to use a universal variable (default).

       See the 'Internals' section for more on them.

   Examples
       abbr -a -g gco git checkout

        Add a new abbreviation where gco will be replaced with git checkout global to the current shell. This abbreviation
       will not be automatically visible to other shells unless the same command is run in those shells (such as when
       executing the commands in config.fish).

       abbr -a -U l less

        Add a new abbreviation where l will be replaced with less universal so all shells. Note that you omit the -U since it
       is the default.

       abbr -r gco gch

        Renames an existing abbreviation from gco to gch.

       abbr -e gco

        Erase the gco abbreviation.

       ssh another_host abbr -s | source

        Import the abbreviations defined on another_host over SSH.

   Internals
       Each abbreviation is stored in its own global or universal variable. The name consists of the prefix _fish_abbr_
       followed by the WORD after being transformed by string escape style=var. The WORD cannot contain a space but all other
       characters are legal.

       Defining an abbreviation with global scope is slightly faster than universal scope (which is the default). But in
       general you'll only want to use the global scope when defining abbreviations in a startup script like
       ~/.config/fish/config.fish like this:

       if status --is-interactive
           abbr --add --global first 'echo my first abbreviation'
           abbr --add --global second 'echo my second abbreviation'
           abbr --add --global gco git checkout
             etcetera
       end

       You can create abbreviations interactively and they will be visible to other fish sessions if you use the -U or
       --universal flag or don't explicitly specify the scope and the abbreviation isn't already defined with global scope. If
       you want it to be visible only to the current shell use the -g or --global flag.

Version 3.0.0  Fri Dec 28 2018  abbr(1)


    abbr(zsh) is a Zsh port of fish shell's abbr
    The preceding is the fish shell abbr's docs as of v3.0.0, December 28 2018
    Source: https://fishshell.com/docs/current/commands.html"

typeset -gA abbrs
abbrs=()

function abbr_error() {
  set -x
  print "abbr $@\nFor help run abbr -h"
}

function abbr_read_universals() {
  if [ -f "$OPT_SOURCE" ]; then
    while read k v; do abbrs[$k]="$v"; done < "$OPT_SOURCE"
  fi
}

function abbr_get_expansion() {
  print ${abbrs[$1]}
}

function abbr_check_options() {
  for arg in "$@"; do
    if "$arg"; then
      abbr_error ": Illegal combination of options"
      exit
    fi
  done
}

function sync_global_abbr() {
  local temp_abbrs="$TMPDIR"abbrArray
  rm $temp_abbrs 2> /dev/null
  mktemp $temp_abbrs 1> /dev/null

  for k v in ${(kv)abbrs}; do
    echo "$k $v" >> "$temp_abbrs"
  done

  mv "$temp_abbrs" "$OPT_SOURCE"
}

function abbr_try_sync_global() {
  if ! $ABBR_OPT_UNIVERSAL; then
    return
  fi

  sync_global_abbr
}

function abbr_add() {
  if [[ $# -lt 2 ]]; then
    abbr_error "-a: Requires at least two arguments"
    exit
  fi

  key="$1"
  shift
  # $@ is value

  abbrs[$key]="'$@'"
  abbr_try_sync_global
}

function abbr_rename() {
  if [[ $# -ne 2 ]]; then
    abbr_error "-r: Requires exactly two arguments"
    exit
  fi

  # $1 is old key
  # $2 is new key
  abbrs[$2]="${abbrs[$1]}"
  unset abbrs["$1"]
  abbr_try_sync_global
}

function abbr_list() {
  if [[ -n $1 ]]; then
    abbr_error "-l: Unexpected argument"
    exit
  fi

  print -l ${(k)abbrs}
}

function abbr_erase() {
  if [[ -n $2 ]]; then
    abbr_error "-e: Expected one argument"
    exit
  elif [[ ! -n $1 ]]; then
    abbr_error "-e: Erase needs a variable name"
    exit
  fi

  if [ "$(abbr_get_expansion $1)" ]; then
    unset abbrs[$1]
    abbr_try_sync_global
  else
    abbr_error "-e: No abbreviation named $1"
    exit
  fi
}

function abbr_show() {
  if [[ -n $1 ]]; then
    abbr_error "-s: Unexpected argument"
    exit
  fi

  for key value in ${(kv)abbrs}; do
    print "$key $value\n"
  done
}

function abbr() {
  local abbr_opt_add=false
  local abbr_opt_rename=false
  local abbr_opt_show=false
  local abbr_opt_list=false
  local abbr_opt_erase=false

  while getopts ":arslegUh" opt; do
    case "$opt" in
      a)
        disallowed_options=($abbr_opt_rename $abbr_opt_show $abbr_opt_list $abbr_opt_erase)
        abbr_check_options $disallowed_options
        abbr_opt_add=true
        ;;
      r)
        disallowed_options=($abbr_opt_add $abbr_opt_show $abbr_opt_list $abbr_opt_erase)
        abbr_check_options $disallowed_options
        abbr_opt_rename=true
        ;;
      s)
        disallowed_options=($abbr_opt_add $abbr_opt_rename $abbr_opt_list $abbr_opt_erase)
        abbr_check_options $disallowed_options
        abbr_opt_show=true
        ;;
      l)
        disallowed_options=($abbr_opt_add $abbr_opt_rename $abbr_opt_show $abbr_opt_erase)
        abbr_check_options $disallowed_options
        abbr_opt_list=true
        ;;
      e)
        disallowed_options=($abbr_opt_add $abbr_opt_rename $abbr_opt_show $abbr_opt_list)
        abbr_check_options $disallowed_options
        abbr_opt_erase=true
        ;;
      g)
        disallowed_options=($ABBR_OPT_UNIVERSAL)
        abbr_check_options $disallowed_options
        ABBR_OPT_GLOBAL=true
        ABBR_OPT_UNIVERSAL=false
        ;;
      U)
        disallowed_options=($ABBR_OPT_GLOBAL)
        abbr_check_options $disallowed_options
        ;;
      h)
        print "$MAN\n"
        exit
        ;;
      *)
        abbr_error "Unknown option '-$OPTARG'"
        ;;
    esac
  done

  shift $((OPTIND-1))

  if $abbr_opt_rename; then
    abbr_rename "$@"
  elif $abbr_opt_list; then
    abbr_list
  elif $abbr_opt_erase; then
    abbr_erase "$@"
  elif $abbr_opt_add || [[ -n $1 ]]; then
    abbr_add "$@"
  else
    abbr_show
  fi
}

function abbr_expand() {
  local current_word="${LBUFFER/*[ ,;|&\n\t]/}"
  local expansion=$(abbr_get_expansion $current_word)

  if [ $expansion ]; then
    local rest="${LBUFFER%%$current_word}"
    LBUFFER="$rest$expansion"
  fi
  zle self-insert
}

abbr_read_universals


zle -N abbr_expand

bindkey " " abbr_expand
bindkey "^ " magic-space
bindkey -M isearch " " magic-space
bindkey -M isearch "^ " abbr_expand

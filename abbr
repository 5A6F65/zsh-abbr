#!/usr/bin/env zsh

# Abbreviation support has two parts:
# abbreviation expansion, and abbreviation management.
# Here management, scoped to the abbr command, follows expansion handling.

typeset -gA ABBRS
typeset -gA ABBRS_GLOBAL
ABBRS=()
ABBRS_GLOBAL=()

if [[ ! -n "$ABBR_UNIVERSALS_SOURCE" ]]; then
  ABBR_UNIVERSALS_SOURCE="$HOME"/.zsh_abbrs
fi

function abbr_expand() {
  {
    function abbr_expand_error() {
      printf "abbr%s\\nFor help run abbr -h\\n" "$@"
      abbr_should_exit=true
    }

    function abbr_get_expansion() {
      printf "%s\\n" "${ABBRS[$1]}"
    }

    local abbreviation=$1
    local expansion

    if ! zle; then
      if [[ "$#" -ne 1 ]]; then
        printf "abbr_expand requires exactly one argument\\n"
        return
      fi

      abbreviation=$1
    else
      abbreviation="${LBUFFER/*[ ,;|&\n\t]/}"
    fi

    expansion="${ABBRS_GLOBAL[$abbreviation]}"

    if [[ ! -n $expansion ]]; then
      source "$TMPDIR"/abbr_universals
      expansion="${ABBRS[$abbreviation]}"
    fi

    if ! zle; then
      printf "%s\\n" "$expansion"
    else
      if [ "$expansion" ]; then
        local rest="${LBUFFER%%$abbreviation}"
        LBUFFER="$rest$expansion"
      fi
    fi
  } always {
    unfunction -m "abbr_get_expansion"
  }
}

function abbr_expand_space() {
  abbr_expand
  LBUFFER="$LBUFFER "
}

if [ -f "$ABBR_UNIVERSALS_SOURCE" ]; then
  while read -r k v; do ABBRS[$k]="$v"; done < "$ABBR_UNIVERSALS_SOURCE"
fi

rm "$TMPDIR"/abbr_universals 2> /dev/null
mktemp "$TMPDIR"/abbr_universals 1> /dev/null

typeset -p ABBRS > "$TMPDIR"/abbr_universals

# spacebar expands abbreviations
zle -N abbr_expand_space
bindkey " " abbr_expand_space

# control-spacebar is a normal space
bindkey "^ " magic-space

# when running an incremental search,
# spacebar behaves normally and control-space expands abbreviations
bindkey -M isearch "^ " abbr_expand_space
bindkey -M isearch " " magic-space



function abbr() {
  {
    local abbr_opt_global=false
    local abbr_opt_universal=false
    local abbr_should_exit=false
    local abbr_opt_add=false
    local abbr_opt_rename=false
    local abbr_opt_show=false
    local abbr_opt_list=false
    local abbr_opt_erase=false
    local abbr_opt_populate=false
    local abbr_opt_git_populate=false
    local abbr_usage="
           abbr(Zsh) is a modified Zsh port of fish shell's abbr abbreviation manager

       Synopsis
           abbr -a [SCOPE] WORD EXPANSION
           abbr -e [SCOPE] word
           abbr -r [SCOPE] OLD_WORD NEW_WORD
           abbr -s
           abbr -l
           abbr -p [SCOPE]
           abbr -i [SCOPE]
           abbr -h

       Description
           abbr manages abbreviations - user-defined words that are replaced with longer phrases after they are entered.

           For example, a frequently-run command like git checkout can be abbreviated to gco. After entering gco and pressing
           [Space], the full text git checkout will appear in the command line.

           To prevent expansion, press [CTRL-SPACE] in place of [SPACE].

       Options
           The following options are available:

           o -a WORD EXPANSION Adds a new abbreviation, causing WORD to be expanded to PHRASE.

           o -e WORD Erases the abbreviation WORD.

           o -r OLD_WORD NEW_WORD Renames an abbreviation, from OLD_WORD to NEW_WORD.

           o -s Show all abbreviations in a manner suitable for export and import.

           o -l Lists all abbreviated words.

           o -p Creates abbreviations for all aliases.

           o -i Creates abbreviations for all git aliases. WORD are prefixed with g,  EXPANSIONs are prefixed with git<space>.

           In addition, when adding abbreviations use

           o -g to create a global abbreviation, available only in the current session.

           o -U to create a universal abbreviation (default), immediately available to all sessions.

           See the 'Internals' section for more on them.

       Examples
           abbr -a -g gco git checkout

            Add a new abbreviation where gco will be replaced with git checkout global to the current shell. This abbreviation
           will not be automatically visible to other shells unless the same command is run in those shells (such as when
           executing the commands in config.fish).

           abbr -a -U l less

            Add a new abbreviation where l will be replaced with less universal so all shells. Note that you omit the -U since it
           is the default.

           abbr -r -g gco gch

            Rename the existing global abbreviation from gco to gch.

           abbr -r l le

            Rename the existing universal abbreviation from l to le. Note that you omit the -U since it is the default.

           abbr -e -g gco

            Erase the global gco abbreviation.

       Internals
           The WORD cannot contain a space but all other characters are legal.

           Defining an abbreviation with global scope is slightly faster than universal scope (which is the default).

           You can create abbreviations interactively and they will be visible to other fish sessions if you use the -U
           flag or don't explicitly specify the scope. If you want it to be visible only to the current shell use the -g flag.

           The options -a -e -r -s -l -p and -i are mutually exclusive, as are the scope options -g and -U.

           The command abbr_expand is available to return an abbreviation's expansion. The result is the global expansion
           if one exists, otherwise the universal expansion if one exists.

           Version 1.1.0 January 26 2019"

    function abbr_usage() {
      print "$abbr_usage\\n"
    }

    function abbr_error() {
      printf "abbr%s\\nFor help run abbr -h\\n" "$@"
      abbr_should_exit=true
    }

    function abbr_bad_options() {
      abbr_error ": Illegal combination of options"
    }

    function abbr_sync_global() {
      local abbr_universals_updated="$TMPDIR"abbr_universals_updated

      typeset -p ABBRS > "$TMPDIR"abbr_universals

      rm "$abbr_universals_updated" 2> /dev/null
      mktemp "$abbr_universals_updated" 1> /dev/null

      for k v in ${(kv)ABBRS}; do
        echo "$k $v" >> "$abbr_universals_updated"
      done

      mv "$abbr_universals_updated" "$ABBR_UNIVERSALS_SOURCE"
    }

    function abbr_add() {
      if [[ $# -lt 2 ]]; then
        abbr_error " -a: Requires at least two arguments"
        return
      fi

      key="$1"
      shift
      # $* is value

      if $abbr_opt_global; then
        if [ ${ABBRS_GLOBAL[(I)$key]} ]; then
          abbr_error " -a: A global abbreviation $key already exists"
          return
        fi

        ABBRS_GLOBAL[$key]="$*"
      else
        if [ ${ABBRS[(I)$key]} ]; then
          abbr_error " -a: A universal abbreviation $key already exists"
          return
        fi

        source "$TMPDIR"abbr_universals
        ABBRS[$key]="$*"
        abbr_sync_global
      fi
    }

    function abbr_erase() {
      if [[ -n $2 ]]; then
        abbr_error " -e: Expected one argument"
        return
      elif [[ ! -n $1 ]]; then
        abbr_error " -e: Erase needs a variable name"
        return
      fi

      if $abbr_opt_global; then
        if [ ${ABBRS_GLOBAL[(I)$1]} ]; then
          unset ABBRS_GLOBAL[$1]
        else
          abbr_error " -e: No global abbreviation named $1"
          return
        fi
      else
        source "$TMPDIR"abbr_universals

        if [ ${ABBRS[(I)$1]} ]; then
          unset ABBRS[$1]
          abbr_sync_global
        else
          abbr_error " -e: No universal abbreviation named $1"
          return
        fi
      fi
    }

    function abbr_rename() {
      if [[ $# -ne 2 ]]; then
        abbr_error " -r: Requires exactly two arguments"
        return
      fi

      if $abbr_opt_global; then
        if [ ${ABBRS_GLOBAL[(I)$1]} ]; then
          ABBRS_GLOBAL[$2]="${ABBRS_GLOBAL[$1]}"
          unset ABBRS_GLOBAL["$1"]
        else
          abbr_error " -r: No global abbreviation named $1"
        fi
      else
        source "$TMPDIR"abbr_universals

        if [ ${ABBRS[(I)$1]} ]; then
          ABBRS[$2]="${ABBRS[$1]}"
          unset ABBRS["$1"]
          abbr_sync_global
        else
          abbr_error " -r: No universal abbreviation named $1"
        fi
      fi
    }

    function abbr_show() {
      if [[ -n $1 ]]; then
        abbr_error " -s: Unexpected argument"
        return
      fi

      source "$TMPDIR"abbr_universals

      for key value in ${(kv)ABBRS}; do
        printf "abbr -a -U -- %s %s\\n" "$key" "$value"
      done

      for key value in ${(kv)ABBRS_GLOBAL}; do
        printf "abbr -a -g -- %s %s\\n" "$key" "$value"
      done
    }

    function abbr_list() {
      if [[ -n $1 ]]; then
        abbr_error " -l: Unexpected argument"
        return
      fi

      source "$TMPDIR"abbr_universals

      print -l ${(k)ABBRS}
      print -l ${(k)ABBRS_GLOBAL}
    }

    function abbr_populate() {
      if [[ -n $1 ]]; then
        abbr_error " -p: Unexpected argument"
        return
      fi

      if $abbr_opt_global; then
        for key value in ${(kv)aliases}; do
          ABBRS_GLOBAL[$key]="$value"
        done
      else
        source "$TMPDIR"abbr_universals

        for key value in ${(kv)aliases}; do
          ABBRS[$key]="$value"
        done

        abbr_sync_global
      fi
    }

    function abbr_git_populate() {
      if [[ -n $1 ]]; then
        abbr_error " -p: Unexpected argument"
        return
      fi

      local git_aliases abbr_git_aliases
      local git_aliases=("${(@f)$(git config --get-regexp '^alias\.')}")
      typeset -A abbr_git_aliases

      for i in $git_aliases; do
        key="${$(echo $i | awk '{print $1;}')##alias.}"
        value="${$(echo $i)##alias.$key }"

        abbr_git_aliases[g$key]="git ${value# }"
      done

      if $abbr_opt_global; then
        for k v in ${(kv)abbr_git_aliases}; do
          ABBRS_GLOBAL[$k]="$v"
        done
      else
        source "$TMPDIR"abbr_universals

        for k v in ${(kv)abbr_git_aliases}; do
          ABBRS[$k]="$v"
        done

        abbr_sync_global
      fi
    }

    while getopts ":haerslpigU" opt; do
      if $abbr_should_exit; then
        abbr_should_exit=false
        return
      fi

      case "$opt" in
        h)
          abbr_usage
          abbr_should_exit=true
          ;;
        a)
          if $abbr_opt_rename || $abbr_opt_show || $abbr_opt_list || $abbr_opt_erase || $abbr_opt_populate || $abbr_opt_git_populate; then
            abbr_bad_options
          fi
          abbr_opt_add=true
          ;;
        e)
          if $abbr_opt_add || $abbr_opt_rename || $abbr_opt_show || $abbr_opt_list || $abbr_opt_populate || $abbr_opt_git_populate; then
            abbr_bad_options
          fi
          abbr_opt_erase=true
          ;;
        r)
          if $abbr_opt_add || $abbr_opt_show || $abbr_opt_list || $abbr_opt_erase || $abbr_opt_populate || $abbr_opt_git_populate; then
            abbr_bad_options
          fi
          abbr_opt_rename=true
          ;;
        s)
          if $abbr_opt_add || $abbr_opt_rename || $abbr_opt_list || $abbr_opt_erase || $abbr_opt_populate || $abbr_opt_git_populate; then
            abbr_bad_options
          fi
          abbr_opt_show=true
          ;;
        l)
          if $abbr_opt_add || $abbr_opt_rename || $abbr_opt_show || $abbr_opt_erase || $abbr_opt_populate || $abbr_opt_git_populate; then
            abbr_bad_options
          fi
          abbr_opt_list=true
          ;;
        p)
          if $abbr_opt_add || $abbr_opt_rename || $abbr_opt_show || $abbr_opt_erase || $abbr_opt_list || $abbr_opt_git_populate; then
            abbr_bad_options
          fi
          abbr_opt_populate=true
          ;;
        i)
          if $abbr_opt_add || $abbr_opt_rename || $abbr_opt_show || $abbr_opt_erase || $abbr_opt_list || $abbr_opt_populate; then
            abbr_bad_options
          fi
          abbr_opt_git_populate=true
          ;;
        g)
          if $abbr_opt_universal; then
            abbr_bad_options
          fi
          abbr_opt_global=true
          ;;
        U)
          if $abbr_opt_global; then
            abbr_bad_options
          fi
          ;;
        *) abbr_error " Unknown option '-$OPTARG'" ;;
      esac
    done

    if $abbr_should_exit; then
      abbr_should_exit=false
      return
    fi

    shift $((OPTIND-1))

    if ! $abbr_opt_global; then
      abbr_opt_universal=true
    fi

    if $abbr_opt_rename; then
      abbr_rename "$@"
    elif $abbr_opt_list; then
      abbr_list "$@"
    elif $abbr_opt_erase; then
      abbr_erase "$@"
    elif $abbr_opt_populate; then
      abbr_populate "$@"
    elif $abbr_opt_git_populate; then
      abbr_git_populate "$@"
    elif $abbr_opt_add; then
       abbr_add "$@"
    elif ! $abbr_opt_show && [[ -n $1 ]]; then
       abbr_add "$@"
    else
      abbr_show "$@"
    fi
  } always {
    unfunction -m "abbr_usage"
    unfunction -m "abbr_error"
    unfunction -m "abbr_bad_options"
    unfunction -m "abbr_sync_global"
    unfunction -m "abbr_add"
    unfunction -m "abbr_rename"
    unfunction -m "abbr_list"
    unfunction -m "abbr_erase"
    unfunction -m "abbr_show"
  }
}
